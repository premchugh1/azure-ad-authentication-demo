{"ast":null,"code":"/*! @azure/msal-browser v3.30.0 2025-08-05 */\n'use strict';\n\nimport { CacheManager, CredentialType, CacheHelpers, AccountEntity, createCacheError, CacheErrorCodes, createClientAuthError, ClientAuthErrorCodes, Constants, PersistentCacheKeys, PerformanceEvents, StringUtils, ProtocolUtils, AuthToken, CacheError, DEFAULT_CRYPTO_IMPLEMENTATION, CcsCredentialType } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { LocalStorage } from './LocalStorage.mjs';\nimport { SessionStorage } from './SessionStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { extractBrowserRequestState } from '../utils/BrowserProtocolUtils.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { CookieStorage } from './CookieStorage.mjs';\nimport { version } from '../packageMetadata.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, noCachedAuthorityError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\nclass BrowserCacheManager extends CacheManager {\n  constructor(clientId, cacheConfig, cryptoImpl, logger, staticAuthorityOptions, performanceClient) {\n    super(clientId, cryptoImpl, logger, staticAuthorityOptions);\n    this.cacheConfig = cacheConfig;\n    this.logger = logger;\n    this.internalStorage = new MemoryStorage();\n    this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\n    this.temporaryCacheStorage = this.setupBrowserStorage(this.cacheConfig.temporaryCacheLocation);\n    this.cookieStorage = new CookieStorage();\n    // Migrate cache entries from older versions of MSAL.\n    if (cacheConfig.cacheMigrationEnabled) {\n      this.migrateCacheEntries();\n      this.createKeyMaps();\n    }\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n  setupBrowserStorage(cacheLocation) {\n    try {\n      switch (cacheLocation) {\n        case BrowserCacheLocation.LocalStorage:\n          return new LocalStorage();\n        case BrowserCacheLocation.SessionStorage:\n          return new SessionStorage();\n        case BrowserCacheLocation.MemoryStorage:\n        default:\n          break;\n      }\n    } catch (e) {\n      this.logger.error(e);\n    }\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  }\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n  migrateCacheEntries() {\n    const previousVersion = this.browserStorage.getItem(StaticCacheKeys.VERSION);\n    if (previousVersion) {\n      this.logger.info(\"MSAL.js was last initialized with version \".concat(previousVersion));\n    }\n    if (previousVersion !== version) {\n      this.browserStorage.setItem(StaticCacheKeys.VERSION, version);\n    }\n    const idTokenKey = \"\".concat(Constants.CACHE_PREFIX, \".\").concat(PersistentCacheKeys.ID_TOKEN);\n    const clientInfoKey = \"\".concat(Constants.CACHE_PREFIX, \".\").concat(PersistentCacheKeys.CLIENT_INFO);\n    const errorKey = \"\".concat(Constants.CACHE_PREFIX, \".\").concat(PersistentCacheKeys.ERROR);\n    const errorDescKey = \"\".concat(Constants.CACHE_PREFIX, \".\").concat(PersistentCacheKeys.ERROR_DESC);\n    const idTokenValue = this.browserStorage.getItem(idTokenKey);\n    const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    const errorValue = this.browserStorage.getItem(errorKey);\n    const errorDescValue = this.browserStorage.getItem(errorDescKey);\n    const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach((cacheKey, index) => {\n      const value = values[index];\n      if (value) {\n        this.setTemporaryCache(cacheKey, value, true);\n      }\n    });\n  }\n  /**\r\n   * Searches all cache entries for MSAL accounts and creates the account key map\r\n   * This is used to migrate users from older versions of MSAL which did not create the map.\r\n   * @returns\r\n   */\n  createKeyMaps() {\n    this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n    const correlationId = this.cryptoImpl.createNewGuid();\n    const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    const tokenKeys = this.getItem(\"\".concat(StaticCacheKeys.TOKEN_KEYS, \".\").concat(this.clientId));\n    if (accountKeys && tokenKeys) {\n      this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\n      // Key maps already exist, no need to iterate through cache\n      return;\n    }\n    const allKeys = this.browserStorage.getKeys();\n    allKeys.forEach(key => {\n      if (this.isCredentialKey(key)) {\n        // Get item, parse, validate and write key to map\n        const value = this.getItem(key);\n        if (value) {\n          const credObj = this.validateAndParseJson(value);\n          if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n            switch (credObj[\"credentialType\"]) {\n              case CredentialType.ID_TOKEN:\n                if (CacheHelpers.isIdTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\n                  this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - idToken with key: \".concat(key, \" found, saving key to token key map\"));\n                  const idTokenEntity = credObj;\n                  const newKey = this.updateCredentialCacheKey(key, idTokenEntity, correlationId);\n                  this.addTokenKey(newKey, CredentialType.ID_TOKEN, correlationId);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\n                  this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed idToken validation on key: \".concat(key));\n                }\n                break;\n              case CredentialType.ACCESS_TOKEN:\n              case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                if (CacheHelpers.isAccessTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\n                  this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - accessToken with key: \".concat(key, \" found, saving key to token key map\"));\n                  const accessTokenEntity = credObj;\n                  const newKey = this.updateCredentialCacheKey(key, accessTokenEntity, correlationId);\n                  this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN, correlationId);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\n                  this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed accessToken validation on key: \".concat(key));\n                }\n                break;\n              case CredentialType.REFRESH_TOKEN:\n                if (CacheHelpers.isRefreshTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\n                  this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - refreshToken with key: \".concat(key, \" found, saving key to token key map\"));\n                  const refreshTokenEntity = credObj;\n                  const newKey = this.updateCredentialCacheKey(key, refreshTokenEntity, correlationId);\n                  this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN, correlationId);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\n                  this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: \".concat(key));\n                }\n                break;\n              // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n            }\n          }\n        }\n      }\n      if (this.isAccountKey(key)) {\n        const value = this.getItem(key);\n        if (value) {\n          const accountObj = this.validateAndParseJson(value);\n          if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\n            this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\n            this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - account with key: \".concat(key, \" found, saving key to account key map\"));\n            this.addAccountKeyToMap(key, correlationId);\n          }\n        }\n      }\n    });\n  }\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n  validateAndParseJson(jsonValue) {\n    try {\n      const parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n  getItem(key) {\n    return this.browserStorage.getItem(key);\n  }\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n  setItem(key, value, correlationId) {\n    let accessTokenKeys = [];\n    const maxRetries = 20;\n    for (let i = 0; i <= maxRetries; i++) {\n      try {\n        this.browserStorage.setItem(key, value);\n        if (i > 0) {\n          // Finally update the token keys array with the tokens removed\n          this.removeAccessTokenKeys(accessTokenKeys.slice(0, i), correlationId);\n        }\n        break; // If setItem succeeds, exit the loop\n      } catch (e) {\n        const cacheError = createCacheError(e);\n        if (cacheError.errorCode === CacheErrorCodes.cacheQuotaExceeded && i < maxRetries) {\n          if (!accessTokenKeys.length) {\n            if (key === \"\".concat(StaticCacheKeys.TOKEN_KEYS, \".\").concat(this.clientId)) {\n              // If we are currently trying to set the token keys, use the value we're trying to set\n              accessTokenKeys = JSON.parse(value).accessToken;\n            } else {\n              // If token keys have not been initialized, get them\n              accessTokenKeys = this.getTokenKeys().accessToken;\n            }\n          }\n          if (accessTokenKeys.length <= i) {\n            // Nothing to remove, rethrow the error\n            throw cacheError;\n          }\n          // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n          this.removeAccessToken(accessTokenKeys[i], correlationId, false // Don't save token keys yet, do it at the end\n          );\n        } else {\n          // If the error is not a quota exceeded error, rethrow it\n          throw cacheError;\n        }\n      }\n    }\n  }\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n  getAccount(accountKey, correlationId, logger) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    const accountEntity = this.getCachedAccountEntity(accountKey, correlationId);\n    return this.updateOutdatedCachedAccount(accountKey, accountEntity, correlationId, logger);\n  }\n  /**\r\n   * Reads account from cache, deserializes it into an account entity and returns it.\r\n   * If account is not found from the key, returns null and removes key from map.\r\n   * @param accountKey\r\n   * @returns\r\n   */\n  getCachedAccountEntity(accountKey, correlationId) {\n    const serializedAccount = this.getItem(accountKey);\n    if (!serializedAccount) {\n      this.removeAccountKeyFromMap(accountKey, correlationId);\n      return null;\n    }\n    const parsedAccount = this.validateAndParseJson(serializedAccount);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  }\n  /**\r\n   * set account entity in the platform cache\r\n   * @param account\r\n   */\n  setAccount(account, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    const key = account.generateAccountKey();\n    account.lastUpdatedAt = Date.now().toString();\n    this.setItem(key, JSON.stringify(account), correlationId);\n    this.addAccountKeyToMap(key, correlationId);\n  }\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n  getAccountKeys() {\n    this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n    const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    if (accountKeys) {\n      return JSON.parse(accountKeys);\n    }\n    this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\n    return [];\n  }\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n  addAccountKeyToMap(key, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.addAccountKeyToMap called with key: \".concat(key));\n    const accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys), correlationId);\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n    }\n  }\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n  removeAccountKeyFromMap(key, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.removeAccountKeyFromMap called with key: \".concat(key));\n    const accountKeys = this.getAccountKeys();\n    const removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      if (accountKeys.length === 0) {\n        // If no keys left, remove the map\n        this.removeItem(StaticCacheKeys.ACCOUNT_KEYS);\n        return;\n      } else {\n        this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys), correlationId);\n      }\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  }\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n  async removeAccount(key, correlationId) {\n    void super.removeAccount(key, correlationId);\n    this.removeAccountKeyFromMap(key, correlationId);\n  }\n  /**\r\n   * Remove account entity from the platform cache if it's outdated\r\n   * @param accountKey\r\n   */\n  removeOutdatedAccount(accountKey, correlationId) {\n    this.removeItem(accountKey);\n    this.removeAccountKeyFromMap(accountKey, correlationId);\n  }\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeIdToken(key, correlationId) {\n    super.removeIdToken(key, correlationId);\n    this.removeTokenKey(key, CredentialType.ID_TOKEN, correlationId);\n  }\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeAccessToken(key, correlationId) {\n    var _this$performanceClie;\n    let updateTokenKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    super.removeAccessToken(key, correlationId);\n    (_this$performanceClie = this.performanceClient) === null || _this$performanceClie === void 0 || _this$performanceClie.incrementFields({\n      accessTokensRemoved: 1\n    }, correlationId);\n    updateTokenKeys && this.removeTokenKey(key, CredentialType.ACCESS_TOKEN, correlationId);\n  }\n  removeAccessTokenKeys(keys, correlationId) {\n    this.logger.trace(\"removeAccessTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    let keysRemoved = 0;\n    keys.forEach(key => {\n      const accessRemoval = tokenKeys.accessToken.indexOf(key);\n      if (accessRemoval > -1) {\n        tokenKeys.accessToken.splice(accessRemoval, 1);\n        keysRemoved++;\n      }\n    });\n    if (keysRemoved > 0) {\n      this.logger.info(\"removed \".concat(keysRemoved, \" accessToken keys from tokenKeys map\"));\n      this.setTokenKeys(tokenKeys, correlationId);\n      return;\n    }\n  }\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeRefreshToken(key, correlationId) {\n    super.removeRefreshToken(key, correlationId);\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN, correlationId);\n  }\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n  getTokenKeys() {\n    this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n    const item = this.getItem(\"\".concat(StaticCacheKeys.TOKEN_KEYS, \".\").concat(this.clientId));\n    if (item) {\n      const tokenKeys = this.validateAndParseJson(item);\n      if (tokenKeys && tokenKeys.hasOwnProperty(\"idToken\") && tokenKeys.hasOwnProperty(\"accessToken\") && tokenKeys.hasOwnProperty(\"refreshToken\")) {\n        return tokenKeys;\n      } else {\n        this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\n      }\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\n    }\n    return {\n      idToken: [],\n      accessToken: [],\n      refreshToken: []\n    };\n  }\n  /**\r\n   * Stores the token keys in the cache\r\n   * @param tokenKeys\r\n   * @param correlationId\r\n   * @returns\r\n   */\n  setTokenKeys(tokenKeys, correlationId) {\n    if (tokenKeys.idToken.length === 0 && tokenKeys.accessToken.length === 0 && tokenKeys.refreshToken.length === 0) {\n      // If no keys left, remove the map\n      this.removeItem(\"\".concat(StaticCacheKeys.TOKEN_KEYS, \".\").concat(this.clientId));\n      return;\n    } else {\n      this.setItem(\"\".concat(StaticCacheKeys.TOKEN_KEYS, \".\").concat(this.clientId), JSON.stringify(tokenKeys), correlationId);\n    }\n  }\n  /**\r\n   * Adds the given key to the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  addTokenKey(key, type, correlationId) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        const index = tokenKeys.accessToken.indexOf(key);\n        if (index !== -1) {\n          tokenKeys.accessToken.splice(index, 1); // Remove existing key before pushing to the end\n        }\n        this.logger.trace(\"access token \".concat(index === -1 ? \"added to\" : \"updated in\", \" map\"));\n        tokenKeys.accessToken.push(key);\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n        break;\n      default:\n        this.logger.error(\"BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: \".concat(type));\n        throw createClientAuthError(ClientAuthErrorCodes.unexpectedCredentialType);\n    }\n    this.setTokenKeys(tokenKeys, correlationId);\n  }\n  /**\r\n   * Removes the given key from the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  removeTokenKey(key, type, correlationId) {\n    let tokenKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.getTokenKeys();\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: \".concat(key, \" from map\"));\n        const idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: \".concat(key, \" from map\"));\n        const accessRemoval = tokenKeys.accessToken.indexOf(key);\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: \".concat(key, \" from map\"));\n        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      default:\n        this.logger.error(\"BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: \".concat(type));\n        throw createClientAuthError(ClientAuthErrorCodes.unexpectedCredentialType);\n    }\n    this.setTokenKeys(tokenKeys, correlationId);\n  }\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n  getIdTokenCredential(idTokenKey, correlationId) {\n    const value = this.getItem(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeIdToken(idTokenKey, correlationId);\n      return null;\n    }\n    const parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return parsedIdToken;\n  }\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n  setIdTokenCredential(idToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n    idToken.lastUpdatedAt = Date.now().toString();\n    this.setItem(idTokenKey, JSON.stringify(idToken), correlationId);\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN, correlationId);\n  }\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n  getAccessTokenCredential(accessTokenKey, correlationId) {\n    const value = this.getItem(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN, correlationId);\n      return null;\n    }\n    const parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !CacheHelpers.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return parsedAccessToken;\n  }\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n  setAccessTokenCredential(accessToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n    accessToken.lastUpdatedAt = Date.now().toString();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken), correlationId);\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN, correlationId);\n  }\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n  getRefreshTokenCredential(refreshTokenKey, correlationId) {\n    const value = this.getItem(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN, correlationId);\n      return null;\n    }\n    const parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return parsedRefreshToken;\n  }\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n  setRefreshTokenCredential(refreshToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    const refreshTokenKey = CacheHelpers.generateCredentialKey(refreshToken);\n    refreshToken.lastUpdatedAt = Date.now().toString();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken), correlationId);\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN, correlationId);\n  }\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n  getAppMetadata(appMetadataKey) {\n    const value = this.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return parsedMetadata;\n  }\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n  setAppMetadata(appMetadata, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata), correlationId);\n  }\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n  getServerTelemetry(serverTelemetryKey) {\n    const value = this.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    const parsedEntity = this.validateAndParseJson(value);\n    if (!parsedEntity || !CacheHelpers.isServerTelemetryEntity(serverTelemetryKey, parsedEntity)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return parsedEntity;\n  }\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n  setServerTelemetry(serverTelemetryKey, serverTelemetry, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry), correlationId);\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadata(key) {\n    const value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return parsedMetadata;\n    }\n    return null;\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadataKeys() {\n    const allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(key => {\n      return this.isAuthorityMetadata(key);\n    });\n  }\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n  setWrapperMetadata(wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  }\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n  getWrapperMetadata() {\n    const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  }\n  /**\r\n   *\r\n   * @param entity\r\n   */\n  setAuthorityMetadata(key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  }\n  /**\r\n   * Gets the active account\r\n   */\n  getActiveAccount(correlationId) {\n    const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      // if new active account cache type isn't found, it's an old version, so look for that instead\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n      const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n      const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n      if (!activeAccountValueLocal) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n      }\n      const activeAccount = this.getAccountInfoFilteredBy({\n        localAccountId: activeAccountValueLocal\n      }, correlationId);\n      if (activeAccount) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n        this.setActiveAccount(activeAccount, correlationId);\n        return activeAccount;\n      }\n      return null;\n    }\n    const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoFilteredBy({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId,\n        tenantId: activeAccountValueObj.tenantId\n      }, correlationId);\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  }\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n  setActiveAccount(account, correlationId) {\n    const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      const activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId,\n        tenantId: account.tenantId,\n        lastUpdatedAt: Date.now().toString()\n      };\n      this.setItem(activeAccountKey, JSON.stringify(activeAccountValue), correlationId);\n      this.setItem(activeAccountKeyLocal, account.localAccountId, correlationId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n      this.browserStorage.removeItem(activeAccountKeyLocal);\n    }\n  }\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n  getThrottlingCache(throttlingCacheKey) {\n    const value = this.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    const parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !CacheHelpers.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return parsedThrottlingCache;\n  }\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n  setThrottlingCache(throttlingCacheKey, throttlingCache, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache), correlationId);\n  }\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  getTemporaryCache(cacheKey, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      const itemCookie = this.cookieStorage.getItem(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    const value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        const item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  }\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n  setTemporaryCache(cacheKey, value, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.cookieStorage.setItem(key, value, undefined, this.cacheConfig.secureCookies);\n    }\n  }\n  /**\r\n   * Removes the cache item with the given key.\r\n   * @param key\r\n   */\n  removeItem(key) {\n    this.browserStorage.removeItem(key);\n  }\n  /**\r\n   * Removes the temporary cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  removeTemporaryItem(key) {\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.cookieStorage.removeItem(key);\n    }\n  }\n  /**\r\n   * Gets all keys in window.\r\n   */\n  getKeys() {\n    return this.browserStorage.getKeys();\n  }\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n  async clear(correlationId) {\n    // Removes all accounts and their credentials\n    await this.removeAllAccounts(correlationId);\n    this.removeAppMetadata(correlationId);\n    // Remove temp storage first to make sure any cookies are cleared\n    this.temporaryCacheStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeTemporaryItem(cacheKey);\n      }\n    });\n    // Removes all remaining MSAL cache items\n    this.browserStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.browserStorage.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  }\n  /**\r\n   * Clears all access tokes that have claims prior to saving the current one\r\n   * @param performanceClient {IPerformanceClient}\r\n   * @param correlationId {string} correlation id\r\n   * @returns\r\n   */\n  async clearTokensAndKeysWithClaims(performanceClient, correlationId) {\n    performanceClient.addQueueMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    let removedAccessTokens = 0;\n    tokenKeys.accessToken.forEach(key => {\n      // if the access token has claims in its key, remove the token key and the token\n      const credential = this.getAccessTokenCredential(key, correlationId);\n      if (credential !== null && credential !== void 0 && credential.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n        this.removeAccessToken(key, correlationId);\n        removedAccessTokens++;\n      }\n    });\n    // warn if any access tokens are removed\n    if (removedAccessTokens > 0) {\n      this.logger.warning(\"\".concat(removedAccessTokens, \" access tokens with claims in the cache keys have been removed from the cache.\"));\n    }\n  }\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n  generateCacheKey(key) {\n    const generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n      return \"\".concat(Constants.CACHE_PREFIX, \".\").concat(this.clientId, \".\").concat(key);\n    }\n    return JSON.stringify(key);\n  }\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n  generateAuthorityKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(\"\".concat(TemporaryCacheKeys.AUTHORITY, \".\").concat(stateId));\n  }\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n  generateNonceKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(\"\".concat(TemporaryCacheKeys.NONCE_IDTOKEN, \".\").concat(stateId));\n  }\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n  generateStateKey(stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(\"\".concat(TemporaryCacheKeys.REQUEST_STATE, \".\").concat(stateId));\n  }\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n  getCachedAuthority(cachedState) {\n    const stateCacheKey = this.generateStateKey(cachedState);\n    const state = this.getTemporaryCache(stateCacheKey);\n    if (!state) {\n      return null;\n    }\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  }\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n  updateCacheEntries(state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n    // Cache the request state\n    const stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false);\n    // Cache the nonce\n    const nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false);\n    // Cache authorityKey\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n    if (account) {\n      const ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (loginHint) {\n      const ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  }\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n  resetRequestCache(state) {\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    // check state and remove associated cache items\n    if (state) {\n      this.temporaryCacheStorage.getKeys().forEach(key => {\n        if (key.indexOf(state) !== -1) {\n          this.removeTemporaryItem(key);\n        }\n      });\n      // delete generic interactive request parameters\n      this.removeTemporaryItem(this.generateStateKey(state));\n      this.removeTemporaryItem(this.generateNonceKey(state));\n      this.removeTemporaryItem(this.generateAuthorityKey(state));\n    }\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  }\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n  cleanRequestByState(stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n    // Interaction is completed - remove interaction status.\n    if (stateString) {\n      const stateKey = this.generateStateKey(stateString);\n      const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \".concat(cachedState));\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n  }\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n  cleanRequestByInteractionType(interactionType) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n    // Loop through all keys to find state key\n    this.temporaryCacheStorage.getKeys().forEach(key => {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      }\n      // Retrieve state value, return if not a valid value\n      const stateValue = this.temporaryCacheStorage.getItem(key);\n      if (!stateValue) {\n        return;\n      }\n      // Extract state and ensure it matches given InteractionType, then clean request cache\n      const parsedState = extractBrowserRequestState(this.cryptoImpl, stateValue);\n      if (parsedState && parsedState.interactionType === interactionType) {\n        this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \".concat(stateValue));\n        this.resetRequestCache(stateValue);\n      }\n    });\n    this.setInteractionInProgress(false);\n  }\n  cacheCodeRequest(authCodeRequest) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  }\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n  getCachedRequest(state) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw createBrowserAuthError(noTokenRequestCacheError);\n    }\n    let parsedRequest;\n    try {\n      parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n    } catch (e) {\n      this.logger.errorPii(\"Attempted to parse: \".concat(encodedTokenRequest));\n      this.logger.error(\"Parsing cached token request threw with error: \".concat(e));\n      throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n    }\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    // Get cached authority and use if no authority is cached with request.\n    if (!parsedRequest.authority) {\n      const authorityCacheKey = this.generateAuthorityKey(state);\n      const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n      if (!cachedAuthority) {\n        throw createBrowserAuthError(noCachedAuthorityError);\n      }\n      parsedRequest.authority = cachedAuthority;\n    }\n    return parsedRequest;\n  }\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n  getCachedNativeRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    const parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  }\n  isInteractionInProgress(matchClientId) {\n    const clientId = this.getInteractionInProgress();\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  }\n  getInteractionInProgress() {\n    const key = \"\".concat(Constants.CACHE_PREFIX, \".\").concat(TemporaryCacheKeys.INTERACTION_STATUS_KEY);\n    return this.getTemporaryCache(key, false);\n  }\n  setInteractionInProgress(inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    const key = \"\".concat(Constants.CACHE_PREFIX, \".\").concat(TemporaryCacheKeys.INTERACTION_STATUS_KEY);\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw createBrowserAuthError(interactionInProgress);\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeTemporaryItem(key);\n    }\n  }\n  /**\r\n   * Returns username retrieved from ADAL or MSAL v1 idToken\r\n   * @deprecated\r\n   */\n  getLegacyLoginHint() {\n    // Only check for adal/msal token if no SSO params are being used\n    const adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    }\n    // Check for cached MSAL v1 id token\n    const msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n    if (msalIdTokenString) {\n      this.browserStorage.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n    const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n    if (cachedIdTokenString) {\n      const idTokenClaims = AuthToken.extractTokenClaims(cachedIdTokenString, base64Decode);\n      if (idTokenClaims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return idTokenClaims.preferred_username;\n      } else if (idTokenClaims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return idTokenClaims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n    return null;\n  }\n  /**\r\n   * Updates a credential's cache key if the current cache key is outdated\r\n   */\n  updateCredentialCacheKey(currentCacheKey, credential, correlationId) {\n    const updatedCacheKey = CacheHelpers.generateCredentialKey(credential);\n    if (currentCacheKey !== updatedCacheKey) {\n      const cacheItem = this.getItem(currentCacheKey);\n      if (cacheItem) {\n        this.browserStorage.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem, correlationId);\n        this.logger.verbose(\"Updated an outdated \".concat(credential.credentialType, \" cache key\"));\n        return updatedCacheKey;\n      } else {\n        this.logger.error(\"Attempted to update an outdated \".concat(credential.credentialType, \" cache key but no item matching the outdated key was found in storage\"));\n      }\n    }\n    return currentCacheKey;\n  }\n  /**\r\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n   * @param result\r\n   * @param request\r\n   */\n  async hydrateCache(result, request) {\n    var _result$account, _result$account2, _result$account3;\n    const idTokenEntity = CacheHelpers.createIdTokenEntity((_result$account = result.account) === null || _result$account === void 0 ? void 0 : _result$account.homeAccountId, (_result$account2 = result.account) === null || _result$account2 === void 0 ? void 0 : _result$account2.environment, result.idToken, this.clientId, result.tenantId);\n    let claimsHash;\n    if (request.claims) {\n      claimsHash = await this.cryptoImpl.hashString(request.claims);\n    }\n    /**\r\n     * meta data for cache stores time in seconds from epoch\r\n     * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\r\n     * We need to map these for the cache when building tokens from AuthenticationResult\r\n     *\r\n     * The next MSAL VFuture should map these both to same value if possible\r\n     */\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity((_result$account3 = result.account) === null || _result$account3 === void 0 ? void 0 : _result$account3.homeAccountId, result.account.environment, result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"), result.expiresOn ? result.expiresOn.getTime() / 1000 : 0, result.extExpiresOn ? result.extExpiresOn.getTime() / 1000 : 0, base64Decode, undefined,\n    // refreshOn\n    result.tokenType, undefined,\n    // userAssertionHash\n    request.sshKid, request.claims, claimsHash);\n    const cacheRecord = {\n      idToken: idTokenEntity,\n      accessToken: accessTokenEntity\n    };\n    return this.saveCacheRecord(cacheRecord, result.correlationId);\n  }\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord {CacheRecord}\r\n   * @param storeInCache {?StoreInCache}\r\n   * @param correlationId {?string} correlation id\r\n   */\n  async saveCacheRecord(cacheRecord, correlationId, storeInCache) {\n    try {\n      await super.saveCacheRecord(cacheRecord, correlationId, storeInCache);\n    } catch (e) {\n      if (e instanceof CacheError && this.performanceClient && correlationId) {\n        try {\n          const tokenKeys = this.getTokenKeys();\n          this.performanceClient.addFields({\n            cacheRtCount: tokenKeys.refreshToken.length,\n            cacheIdCount: tokenKeys.idToken.length,\n            cacheAtCount: tokenKeys.accessToken.length\n          }, correlationId);\n        } catch (e) {}\n      }\n      throw e;\n    }\n  }\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger) => {\n  const cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["BrowserCacheManager","CacheManager","constructor","clientId","cacheConfig","cryptoImpl","logger","staticAuthorityOptions","performanceClient","internalStorage","MemoryStorage","browserStorage","setupBrowserStorage","cacheLocation","temporaryCacheStorage","temporaryCacheLocation","cookieStorage","CookieStorage","cacheMigrationEnabled","migrateCacheEntries","createKeyMaps","BrowserCacheLocation","LocalStorage","SessionStorage","e","error","previousVersion","getItem","StaticCacheKeys","VERSION","info","concat","version","setItem","idTokenKey","Constants","CACHE_PREFIX","PersistentCacheKeys","ID_TOKEN","clientInfoKey","CLIENT_INFO","errorKey","ERROR","errorDescKey","ERROR_DESC","idTokenValue","clientInfoValue","errorValue","errorDescValue","values","keysToMigrate","forEach","cacheKey","index","value","setTemporaryCache","trace","correlationId","createNewGuid","accountKeys","ACCOUNT_KEYS","tokenKeys","TOKEN_KEYS","verbose","allKeys","getKeys","key","isCredentialKey","credObj","validateAndParseJson","hasOwnProperty","CredentialType","CacheHelpers","isIdTokenEntity","tracePii","idTokenEntity","newKey","updateCredentialCacheKey","addTokenKey","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","isAccessTokenEntity","accessTokenEntity","REFRESH_TOKEN","isRefreshTokenEntity","refreshTokenEntity","isAccountKey","accountObj","AccountEntity","isAccountEntity","addAccountKeyToMap","jsonValue","parsedJson","JSON","parse","accessTokenKeys","maxRetries","i","removeAccessTokenKeys","slice","cacheError","createCacheError","errorCode","CacheErrorCodes","cacheQuotaExceeded","length","accessToken","getTokenKeys","removeAccessToken","getAccount","accountKey","accountEntity","getCachedAccountEntity","updateOutdatedCachedAccount","serializedAccount","removeAccountKeyFromMap","parsedAccount","toObject","setAccount","account","generateAccountKey","lastUpdatedAt","Date","now","toString","stringify","getAccountKeys","indexOf","push","removalIndex","splice","removeItem","removeAccount","removeOutdatedAccount","removeIdToken","removeTokenKey","_this$performanceClie","updateTokenKeys","arguments","undefined","incrementFields","accessTokensRemoved","keys","keysRemoved","accessRemoval","setTokenKeys","removeRefreshToken","item","idToken","refreshToken","type","createClientAuthError","ClientAuthErrorCodes","unexpectedCredentialType","infoPii","idRemoval","refreshRemoval","getIdTokenCredential","parsedIdToken","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","setRefreshTokenCredential","getAppMetadata","appMetadataKey","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","parsedEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","InMemoryCacheKeys","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","EMPTY_STRING","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountKeyLocal","ACTIVE_ACCOUNT","activeAccountValueLocal","activeAccount","getAccountInfoFilteredBy","localAccountId","setActiveAccount","activeAccountValueObj","homeAccountId","tenantId","activeAccountKey","activeAccountValue","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","generateKey","storeAuthStateInCookie","itemCookie","secureCookies","removeTemporaryItem","clear","removeAllAccounts","removeAppMetadata","clearTokensAndKeysWithClaims","addQueueMeasurement","PerformanceEvents","ClearTokensAndKeysWithClaims","removedAccessTokens","credential","requestedClaimsHash","includes","toLowerCase","warning","generatedKey","StringUtils","startsWith","ADAL_ID_TOKEN","generateAuthorityKey","stateString","libraryState","id","stateId","ProtocolUtils","parseRequestState","TemporaryCacheKeys","AUTHORITY","generateNonceKey","NONCE_IDTOKEN","generateStateKey","REQUEST_STATE","getCachedAuthority","cachedState","stateCacheKey","state","authorityCacheKey","updateCacheEntries","nonce","authorityInstance","loginHint","nonceCacheKey","ccsCredential","CcsCredentialType","HOME_ACCOUNT_ID","CCS_CREDENTIAL","UPN","resetRequestCache","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","CORRELATION_ID","NATIVE_REQUEST","setInteractionInProgress","cleanRequestByState","stateKey","cleanRequestByInteractionType","interactionType","stateValue","parsedState","extractBrowserRequestState","cacheCodeRequest","authCodeRequest","encodedValue","base64Encode","getCachedRequest","encodedTokenRequest","createBrowserAuthError","noTokenRequestCacheError","parsedRequest","base64Decode","errorPii","unableToParseTokenRequestCacheError","authority","cachedAuthority","noCachedAuthorityError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","interactionInProgress","getLegacyLoginHint","adalIdTokenString","msalIdTokenString","cachedIdTokenString","idTokenClaims","AuthToken","extractTokenClaims","preferred_username","upn","currentCacheKey","updatedCacheKey","cacheItem","credentialType","hydrateCache","result","request","_result$account","_result$account2","_result$account3","createIdTokenEntity","environment","claimsHash","claims","hashString","createAccessTokenEntity","scopes","join","expiresOn","getTime","extExpiresOn","tokenType","sshKid","cacheRecord","saveCacheRecord","storeInCache","CacheError","addFields","cacheRtCount","cacheIdCount","cacheAtCount","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","claimsBasedCachingEnabled","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["C:\\Users\\prchugh\\AzureADApp\\spa\\node_modules\\@azure\\msal-browser\\src\\cache\\BrowserCacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Constants,\n    PersistentCacheKeys,\n    StringUtils,\n    CommonAuthorizationCodeRequest,\n    ICrypto,\n    AccountEntity,\n    IdTokenEntity,\n    AccessTokenEntity,\n    RefreshTokenEntity,\n    AppMetadataEntity,\n    CacheManager,\n    ServerTelemetryEntity,\n    ThrottlingEntity,\n    ProtocolUtils,\n    Logger,\n    AuthorityMetadataEntity,\n    DEFAULT_CRYPTO_IMPLEMENTATION,\n    AccountInfo,\n    ActiveAccountFilters,\n    CcsCredential,\n    CcsCredentialType,\n    AuthToken,\n    ValidCredentialType,\n    TokenKeys,\n    CredentialType,\n    CacheRecord,\n    AuthenticationScheme,\n    createClientAuthError,\n    ClientAuthErrorCodes,\n    PerformanceEvents,\n    IPerformanceClient,\n    StaticAuthorityOptions,\n    CacheHelpers,\n    StoreInCache,\n    CacheError,\n    CacheErrorCodes,\n    createCacheError,\n} from \"@azure/msal-common/browser\";\nimport { CacheOptions } from \"../config/Configuration.js\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError.js\";\nimport {\n    BrowserCacheLocation,\n    InteractionType,\n    TemporaryCacheKeys,\n    InMemoryCacheKeys,\n    StaticCacheKeys,\n} from \"../utils/BrowserConstants.js\";\nimport { LocalStorage } from \"./LocalStorage.js\";\nimport { SessionStorage } from \"./SessionStorage.js\";\nimport { MemoryStorage } from \"./MemoryStorage.js\";\nimport { IWindowStorage } from \"./IWindowStorage.js\";\nimport { extractBrowserRequestState } from \"../utils/BrowserProtocolUtils.js\";\nimport { NativeTokenRequest } from \"../broker/nativeBroker/NativeRequest.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { SilentRequest } from \"../request/SilentRequest.js\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest.js\";\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\nimport { PopupRequest } from \"../request/PopupRequest.js\";\nimport { base64Decode } from \"../encode/Base64Decode.js\";\nimport { base64Encode } from \"../encode/Base64Encode.js\";\nimport { CookieStorage } from \"./CookieStorage.js\";\nimport { version } from \"../packageMetadata.js\";\n\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nexport class BrowserCacheManager extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    protected cacheConfig: Required<CacheOptions>;\n    // Window storage object (either local or sessionStorage)\n    protected browserStorage: IWindowStorage<string>;\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\n    protected internalStorage: MemoryStorage<string>;\n    // Temporary cache\n    protected temporaryCacheStorage: IWindowStorage<string>;\n    // Cookie storage\n    protected cookieStorage: CookieStorage;\n    // Logger instance\n    protected logger: Logger;\n    // Telemetry perf client\n    protected performanceClient?: IPerformanceClient;\n\n    constructor(\n        clientId: string,\n        cacheConfig: Required<CacheOptions>,\n        cryptoImpl: ICrypto,\n        logger: Logger,\n        staticAuthorityOptions?: StaticAuthorityOptions,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(clientId, cryptoImpl, logger, staticAuthorityOptions);\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = this.setupBrowserStorage(\n            this.cacheConfig.cacheLocation\n        );\n        this.temporaryCacheStorage = this.setupBrowserStorage(\n            this.cacheConfig.temporaryCacheLocation\n        );\n        this.cookieStorage = new CookieStorage();\n\n        // Migrate cache entries from older versions of MSAL.\n        if (cacheConfig.cacheMigrationEnabled) {\n            this.migrateCacheEntries();\n            this.createKeyMaps();\n        }\n\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n     * @param cacheLocation\n     */\n    protected setupBrowserStorage(\n        cacheLocation: BrowserCacheLocation | string\n    ): IWindowStorage<string> {\n        try {\n            switch (cacheLocation) {\n                case BrowserCacheLocation.LocalStorage:\n                    return new LocalStorage();\n                case BrowserCacheLocation.SessionStorage:\n                    return new SessionStorage();\n                case BrowserCacheLocation.MemoryStorage:\n                default:\n                    break;\n            }\n        } catch (e) {\n            this.logger.error(e as string);\n        }\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n        return new MemoryStorage();\n    }\n\n    /**\n     * Migrate all old cache entries to new schema. No rollback supported.\n     * @param storeAuthStateInCookie\n     */\n    protected migrateCacheEntries(): void {\n        const previousVersion = this.browserStorage.getItem(\n            StaticCacheKeys.VERSION\n        );\n        if (previousVersion) {\n            this.logger.info(\n                `MSAL.js was last initialized with version ${previousVersion}`\n            );\n        }\n\n        if (previousVersion !== version) {\n            this.browserStorage.setItem(StaticCacheKeys.VERSION, version);\n        }\n\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\n\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n        const errorValue = this.browserStorage.getItem(errorKey);\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\n\n        const values = [\n            idTokenValue,\n            clientInfoValue,\n            errorValue,\n            errorDescValue,\n        ];\n        const keysToMigrate = [\n            PersistentCacheKeys.ID_TOKEN,\n            PersistentCacheKeys.CLIENT_INFO,\n            PersistentCacheKeys.ERROR,\n            PersistentCacheKeys.ERROR_DESC,\n        ];\n\n        keysToMigrate.forEach((cacheKey: string, index: number) => {\n            const value = values[index];\n            if (value) {\n                this.setTemporaryCache(cacheKey, value, true);\n            }\n        });\n    }\n\n    /**\n     * Searches all cache entries for MSAL accounts and creates the account key map\n     * This is used to migrate users from older versions of MSAL which did not create the map.\n     * @returns\n     */\n    private createKeyMaps(): void {\n        this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n        const correlationId = this.cryptoImpl.createNewGuid();\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n        const tokenKeys = this.getItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`\n        );\n        if (accountKeys && tokenKeys) {\n            this.logger.verbose(\n                \"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\"\n            );\n            // Key maps already exist, no need to iterate through cache\n            return;\n        }\n\n        const allKeys = this.browserStorage.getKeys();\n        allKeys.forEach((key) => {\n            if (this.isCredentialKey(key)) {\n                // Get item, parse, validate and write key to map\n                const value = this.getItem(key);\n                if (value) {\n                    const credObj = this.validateAndParseJson(value);\n                    if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n                        switch (credObj[\"credentialType\"]) {\n                            case CredentialType.ID_TOKEN:\n                                if (CacheHelpers.isIdTokenEntity(credObj)) {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - idToken with key: ${key} found, saving key to token key map`\n                                    );\n                                    const idTokenEntity =\n                                        credObj as IdTokenEntity;\n                                    const newKey =\n                                        this.updateCredentialCacheKey(\n                                            key,\n                                            idTokenEntity,\n                                            correlationId\n                                        );\n                                    this.addTokenKey(\n                                        newKey,\n                                        CredentialType.ID_TOKEN,\n                                        correlationId\n                                    );\n                                    return;\n                                } else {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - failed idToken validation on key: ${key}`\n                                    );\n                                }\n                                break;\n                            case CredentialType.ACCESS_TOKEN:\n                            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                                if (CacheHelpers.isAccessTokenEntity(credObj)) {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - accessToken with key: ${key} found, saving key to token key map`\n                                    );\n                                    const accessTokenEntity =\n                                        credObj as AccessTokenEntity;\n                                    const newKey =\n                                        this.updateCredentialCacheKey(\n                                            key,\n                                            accessTokenEntity,\n                                            correlationId\n                                        );\n                                    this.addTokenKey(\n                                        newKey,\n                                        CredentialType.ACCESS_TOKEN,\n                                        correlationId\n                                    );\n                                    return;\n                                } else {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - failed accessToken validation on key: ${key}`\n                                    );\n                                }\n                                break;\n                            case CredentialType.REFRESH_TOKEN:\n                                if (\n                                    CacheHelpers.isRefreshTokenEntity(credObj)\n                                ) {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - refreshToken with key: ${key} found, saving key to token key map`\n                                    );\n                                    const refreshTokenEntity =\n                                        credObj as RefreshTokenEntity;\n                                    const newKey =\n                                        this.updateCredentialCacheKey(\n                                            key,\n                                            refreshTokenEntity,\n                                            correlationId\n                                        );\n                                    this.addTokenKey(\n                                        newKey,\n                                        CredentialType.REFRESH_TOKEN,\n                                        correlationId\n                                    );\n                                    return;\n                                } else {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: ${key}`\n                                    );\n                                }\n                                break;\n                            default:\n                            // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n                        }\n                    }\n                }\n            }\n\n            if (this.isAccountKey(key)) {\n                const value = this.getItem(key);\n                if (value) {\n                    const accountObj = this.validateAndParseJson(value);\n                    if (\n                        accountObj &&\n                        AccountEntity.isAccountEntity(accountObj)\n                    ) {\n                        this.logger.trace(\n                            \"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\"\n                        );\n                        this.logger.tracePii(\n                            `BrowserCacheManager:createKeyMaps - account with key: ${key} found, saving key to account key map`\n                        );\n                        this.addAccountKeyToMap(key, correlationId);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    protected validateAndParseJson(jsonValue: string): object | null {\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return parsedJson && typeof parsedJson === \"object\"\n                ? parsedJson\n                : null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * fetches the entry from the browser storage based off the key\n     * @param key\n     */\n    getItem(key: string): string | null {\n        return this.browserStorage.getItem(key);\n    }\n\n    /**\n     * sets the entry in the browser storage\n     * @param key\n     * @param value\n     */\n    setItem(key: string, value: string, correlationId: string): void {\n        let accessTokenKeys: Array<string> = [];\n        const maxRetries = 20;\n        for (let i = 0; i <= maxRetries; i++) {\n            try {\n                this.browserStorage.setItem(key, value);\n                if (i > 0) {\n                    // Finally update the token keys array with the tokens removed\n                    this.removeAccessTokenKeys(\n                        accessTokenKeys.slice(0, i),\n                        correlationId\n                    );\n                }\n                break; // If setItem succeeds, exit the loop\n            } catch (e) {\n                const cacheError = createCacheError(e);\n                if (\n                    cacheError.errorCode ===\n                        CacheErrorCodes.cacheQuotaExceeded &&\n                    i < maxRetries\n                ) {\n                    if (!accessTokenKeys.length) {\n                        if (\n                            key ===\n                            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`\n                        ) {\n                            // If we are currently trying to set the token keys, use the value we're trying to set\n                            accessTokenKeys = (JSON.parse(value) as TokenKeys)\n                                .accessToken;\n                        } else {\n                            // If token keys have not been initialized, get them\n                            accessTokenKeys = this.getTokenKeys().accessToken;\n                        }\n                    }\n                    if (accessTokenKeys.length <= i) {\n                        // Nothing to remove, rethrow the error\n                        throw cacheError;\n                    }\n                    // When cache quota is exceeded, start removing access tokens until we can successfully set the item\n                    this.removeAccessToken(\n                        accessTokenKeys[i],\n                        correlationId,\n                        false // Don't save token keys yet, do it at the end\n                    );\n                } else {\n                    // If the error is not a quota exceeded error, rethrow it\n                    throw cacheError;\n                }\n            }\n        }\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     * @param accountKey\n     */\n    getAccount(\n        accountKey: string,\n        correlationId: string,\n        logger?: Logger\n    ): AccountEntity | null {\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\n        const accountEntity = this.getCachedAccountEntity(\n            accountKey,\n            correlationId\n        );\n\n        return this.updateOutdatedCachedAccount(\n            accountKey,\n            accountEntity,\n            correlationId,\n            logger\n        );\n    }\n\n    /**\n     * Reads account from cache, deserializes it into an account entity and returns it.\n     * If account is not found from the key, returns null and removes key from map.\n     * @param accountKey\n     * @returns\n     */\n    getCachedAccountEntity(\n        accountKey: string,\n        correlationId: string\n    ): AccountEntity | null {\n        const serializedAccount = this.getItem(accountKey);\n        if (!serializedAccount) {\n            this.removeAccountKeyFromMap(accountKey, correlationId);\n            return null;\n        }\n\n        const parsedAccount = this.validateAndParseJson(serializedAccount);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            return null;\n        }\n\n        return CacheManager.toObject<AccountEntity>(\n            new AccountEntity(),\n            parsedAccount\n        );\n    }\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    setAccount(account: AccountEntity, correlationId: string): void {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = account.generateAccountKey();\n        account.lastUpdatedAt = Date.now().toString();\n        this.setItem(key, JSON.stringify(account), correlationId);\n        this.addAccountKeyToMap(key, correlationId);\n    }\n\n    /**\n     * Returns the array of account keys currently cached\n     * @returns\n     */\n    getAccountKeys(): Array<string> {\n        this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n        if (accountKeys) {\n            return JSON.parse(accountKeys);\n        }\n\n        this.logger.verbose(\n            \"BrowserCacheManager.getAccountKeys - No account keys found\"\n        );\n        return [];\n    }\n\n    /**\n     * Add a new account to the key map\n     * @param key\n     */\n    addAccountKeyToMap(key: string, correlationId: string): void {\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.addAccountKeyToMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        if (accountKeys.indexOf(key) === -1) {\n            // Only add key if it does not already exist in the map\n            accountKeys.push(key);\n            this.setItem(\n                StaticCacheKeys.ACCOUNT_KEYS,\n                JSON.stringify(accountKeys),\n                correlationId\n            );\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key added\"\n            );\n        } else {\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key already exists in map\"\n            );\n        }\n    }\n\n    /**\n     * Remove an account from the key map\n     * @param key\n     */\n    removeAccountKeyFromMap(key: string, correlationId: string): void {\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        const removalIndex = accountKeys.indexOf(key);\n        if (removalIndex > -1) {\n            accountKeys.splice(removalIndex, 1);\n            if (accountKeys.length === 0) {\n                // If no keys left, remove the map\n                this.removeItem(StaticCacheKeys.ACCOUNT_KEYS);\n                return;\n            } else {\n                this.setItem(\n                    StaticCacheKeys.ACCOUNT_KEYS,\n                    JSON.stringify(accountKeys),\n                    correlationId\n                );\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap account key removed\"\n            );\n        } else {\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\"\n            );\n        }\n    }\n\n    /**\n     * Extends inherited removeAccount function to include removal of the account key from the map\n     * @param key\n     */\n    async removeAccount(key: string, correlationId: string): Promise<void> {\n        void super.removeAccount(key, correlationId);\n        this.removeAccountKeyFromMap(key, correlationId);\n    }\n\n    /**\n     * Remove account entity from the platform cache if it's outdated\n     * @param accountKey\n     */\n    removeOutdatedAccount(accountKey: string, correlationId: string): void {\n        this.removeItem(accountKey);\n        this.removeAccountKeyFromMap(accountKey, correlationId);\n    }\n\n    /**\n     * Removes given idToken from the cache and from the key map\n     * @param key\n     */\n    removeIdToken(key: string, correlationId: string): void {\n        super.removeIdToken(key, correlationId);\n        this.removeTokenKey(key, CredentialType.ID_TOKEN, correlationId);\n    }\n\n    /**\n     * Removes given accessToken from the cache and from the key map\n     * @param key\n     */\n    removeAccessToken(\n        key: string,\n        correlationId: string,\n        updateTokenKeys: boolean = true\n    ): void {\n        super.removeAccessToken(key, correlationId);\n        this.performanceClient?.incrementFields(\n            { accessTokensRemoved: 1 },\n            correlationId\n        );\n        updateTokenKeys &&\n            this.removeTokenKey(\n                key,\n                CredentialType.ACCESS_TOKEN,\n                correlationId\n            );\n    }\n\n    removeAccessTokenKeys(keys: Array<string>, correlationId: string): void {\n        this.logger.trace(\"removeAccessTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n        let keysRemoved = 0;\n        keys.forEach((key) => {\n            const accessRemoval = tokenKeys.accessToken.indexOf(key);\n            if (accessRemoval > -1) {\n                tokenKeys.accessToken.splice(accessRemoval, 1);\n                keysRemoved++;\n            }\n        });\n\n        if (keysRemoved > 0) {\n            this.logger.info(\n                `removed ${keysRemoved} accessToken keys from tokenKeys map`\n            );\n            this.setTokenKeys(tokenKeys, correlationId);\n            return;\n        }\n    }\n\n    /**\n     * Removes given refreshToken from the cache and from the key map\n     * @param key\n     */\n    removeRefreshToken(key: string, correlationId: string): void {\n        super.removeRefreshToken(key, correlationId);\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN, correlationId);\n    }\n\n    /**\n     * Gets the keys for the cached tokens associated with this clientId\n     * @returns\n     */\n    getTokenKeys(): TokenKeys {\n        this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n        const item = this.getItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`\n        );\n        if (item) {\n            const tokenKeys = this.validateAndParseJson(item);\n            if (\n                tokenKeys &&\n                tokenKeys.hasOwnProperty(\"idToken\") &&\n                tokenKeys.hasOwnProperty(\"accessToken\") &&\n                tokenKeys.hasOwnProperty(\"refreshToken\")\n            ) {\n                return tokenKeys as TokenKeys;\n            } else {\n                this.logger.error(\n                    \"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\"\n                );\n            }\n        } else {\n            this.logger.verbose(\n                \"BrowserCacheManager.getTokenKeys - No token keys found\"\n            );\n        }\n\n        return {\n            idToken: [],\n            accessToken: [],\n            refreshToken: [],\n        };\n    }\n\n    /**\n     * Stores the token keys in the cache\n     * @param tokenKeys\n     * @param correlationId\n     * @returns\n     */\n    setTokenKeys(tokenKeys: TokenKeys, correlationId: string): void {\n        if (\n            tokenKeys.idToken.length === 0 &&\n            tokenKeys.accessToken.length === 0 &&\n            tokenKeys.refreshToken.length === 0\n        ) {\n            // If no keys left, remove the map\n            this.removeItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n            return;\n        } else {\n            this.setItem(\n                `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\n                JSON.stringify(tokenKeys),\n                correlationId\n            );\n        }\n    }\n\n    /**\n     * Adds the given key to the token key map\n     * @param key\n     * @param type\n     */\n    addTokenKey(\n        key: string,\n        type: CredentialType,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                if (tokenKeys.idToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - idToken added to map\"\n                    );\n                    tokenKeys.idToken.push(key);\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                const index = tokenKeys.accessToken.indexOf(key);\n                if (index !== -1) {\n                    tokenKeys.accessToken.splice(index, 1); // Remove existing key before pushing to the end\n                }\n                this.logger.trace(\n                    `access token ${\n                        index === -1 ? \"added to\" : \"updated in\"\n                    } map`\n                );\n                tokenKeys.accessToken.push(key);\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - refreshToken added to map\"\n                    );\n                    tokenKeys.refreshToken.push(key);\n                }\n                break;\n            default:\n                this.logger.error(\n                    `BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`\n                );\n                throw createClientAuthError(\n                    ClientAuthErrorCodes.unexpectedCredentialType\n                );\n        }\n\n        this.setTokenKeys(tokenKeys, correlationId);\n    }\n\n    /**\n     * Removes the given key from the token key map\n     * @param key\n     * @param type\n     */\n    removeTokenKey(\n        key: string,\n        type: CredentialType,\n        correlationId: string,\n        tokenKeys: TokenKeys = this.getTokenKeys()\n    ): void {\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`\n                );\n                const idRemoval = tokenKeys.idToken.indexOf(key);\n                if (idRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - idToken removed from map\"\n                    );\n                    tokenKeys.idToken.splice(idRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`\n                );\n                const accessRemoval = tokenKeys.accessToken.indexOf(key);\n                if (accessRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - accessToken removed from map\"\n                    );\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`\n                );\n                const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n                if (refreshRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - refreshToken removed from map\"\n                    );\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            default:\n                this.logger.error(\n                    `BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`\n                );\n                throw createClientAuthError(\n                    ClientAuthErrorCodes.unexpectedCredentialType\n                );\n        }\n\n        this.setTokenKeys(tokenKeys, correlationId);\n    }\n\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(\n        idTokenKey: string,\n        correlationId: string\n    ): IdTokenEntity | null {\n        const value = this.getItem(idTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            this.removeIdToken(idTokenKey, correlationId);\n            return null;\n        }\n\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getIdTokenCredential: cache hit\"\n        );\n        return parsedIdToken as IdTokenEntity;\n    }\n\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    setIdTokenCredential(idToken: IdTokenEntity, correlationId: string): void {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n        idToken.lastUpdatedAt = Date.now().toString();\n\n        this.setItem(idTokenKey, JSON.stringify(idToken), correlationId);\n\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN, correlationId);\n    }\n\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(\n        accessTokenKey: string,\n        correlationId: string\n    ): AccessTokenEntity | null {\n        const value = this.getItem(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(\n                accessTokenKey,\n                CredentialType.ACCESS_TOKEN,\n                correlationId\n            );\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (\n            !parsedAccessToken ||\n            !CacheHelpers.isAccessTokenEntity(parsedAccessToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getAccessTokenCredential: cache hit\"\n        );\n        return parsedAccessToken as AccessTokenEntity;\n    }\n\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    setAccessTokenCredential(\n        accessToken: AccessTokenEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\n            \"BrowserCacheManager.setAccessTokenCredential called\"\n        );\n        const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n        accessToken.lastUpdatedAt = Date.now().toString();\n\n        this.setItem(\n            accessTokenKey,\n            JSON.stringify(accessToken),\n            correlationId\n        );\n\n        this.addTokenKey(\n            accessTokenKey,\n            CredentialType.ACCESS_TOKEN,\n            correlationId\n        );\n    }\n\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(\n        refreshTokenKey: string,\n        correlationId: string\n    ): RefreshTokenEntity | null {\n        const value = this.getItem(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(\n                refreshTokenKey,\n                CredentialType.REFRESH_TOKEN,\n                correlationId\n            );\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (\n            !parsedRefreshToken ||\n            !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getRefreshTokenCredential: cache hit\"\n        );\n        return parsedRefreshToken as RefreshTokenEntity;\n    }\n\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    setRefreshTokenCredential(\n        refreshToken: RefreshTokenEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\n            \"BrowserCacheManager.setRefreshTokenCredential called\"\n        );\n        const refreshTokenKey =\n            CacheHelpers.generateCredentialKey(refreshToken);\n\n        refreshToken.lastUpdatedAt = Date.now().toString();\n        this.setItem(\n            refreshTokenKey,\n            JSON.stringify(refreshToken),\n            correlationId\n        );\n\n        this.addTokenKey(\n            refreshTokenKey,\n            CredentialType.REFRESH_TOKEN,\n            correlationId\n        );\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const value = this.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            !parsedMetadata ||\n            !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return parsedMetadata as AppMetadataEntity;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(\n        appMetadata: AppMetadataEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n        this.setItem(\n            appMetadataKey,\n            JSON.stringify(appMetadata),\n            correlationId\n        );\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(\n        serverTelemetryKey: string\n    ): ServerTelemetryEntity | null {\n        const value = this.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedEntity = this.validateAndParseJson(value);\n        if (\n            !parsedEntity ||\n            !CacheHelpers.isServerTelemetryEntity(\n                serverTelemetryKey,\n                parsedEntity\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return parsedEntity as ServerTelemetryEntity;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.setItem(\n            serverTelemetryKey,\n            JSON.stringify(serverTelemetry),\n            correlationId\n        );\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            parsedMetadata &&\n            CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: cache hit\"\n            );\n            return parsedMetadata as AuthorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU\n     * @param wrapperVersion\n     */\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(\n            InMemoryCacheKeys.WRAPPER_VER,\n            wrapperVersion\n        );\n    }\n\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata(): [string, string] {\n        const sku =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) ||\n            Constants.EMPTY_STRING;\n        const version =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) ||\n            Constants.EMPTY_STRING;\n        return [sku, version];\n    }\n\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n\n    /**\n     * Gets the active account\n     */\n    getActiveAccount(correlationId: string): AccountInfo | null {\n        const activeAccountKeyFilters = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n        if (!activeAccountValueFilters) {\n            // if new active account cache type isn't found, it's an old version, so look for that instead\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\"\n            );\n            const activeAccountKeyLocal = this.generateCacheKey(\n                PersistentCacheKeys.ACTIVE_ACCOUNT\n            );\n            const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n            if (!activeAccountValueLocal) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getActiveAccount: No active account found\"\n                );\n                return null;\n            }\n            const activeAccount = this.getAccountInfoFilteredBy(\n                {\n                    localAccountId: activeAccountValueLocal,\n                },\n                correlationId\n            );\n            if (activeAccount) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\"\n                );\n                this.logger.trace(\n                    \"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\"\n                );\n                this.setActiveAccount(activeAccount, correlationId);\n                return activeAccount;\n            }\n            return null;\n        }\n        const activeAccountValueObj = this.validateAndParseJson(\n            activeAccountValueFilters\n        ) as AccountInfo;\n        if (activeAccountValueObj) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: Active account filters schema found\"\n            );\n            return this.getAccountInfoFilteredBy(\n                {\n                    homeAccountId: activeAccountValueObj.homeAccountId,\n                    localAccountId: activeAccountValueObj.localAccountId,\n                    tenantId: activeAccountValueObj.tenantId,\n                },\n                correlationId\n            );\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getActiveAccount: No active account found\"\n        );\n        return null;\n    }\n\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null, correlationId: string): void {\n        const activeAccountKey = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        const activeAccountKeyLocal = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT\n        );\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            const activeAccountValue: ActiveAccountFilters = {\n                homeAccountId: account.homeAccountId,\n                localAccountId: account.localAccountId,\n                tenantId: account.tenantId,\n                lastUpdatedAt: Date.now().toString(),\n            };\n            this.setItem(\n                activeAccountKey,\n                JSON.stringify(activeAccountValue),\n                correlationId\n            );\n            this.setItem(\n                activeAccountKeyLocal,\n                account.localAccountId,\n                correlationId\n            );\n        } else {\n            this.logger.verbose(\n                \"setActiveAccount: No account passed, active account not set\"\n            );\n            this.browserStorage.removeItem(activeAccountKey);\n            this.browserStorage.removeItem(activeAccountKeyLocal);\n        }\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const value = this.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (\n            !parsedThrottlingCache ||\n            !CacheHelpers.isThrottlingEntity(\n                throttlingCacheKey,\n                parsedThrottlingCache\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return parsedThrottlingCache as ThrottlingEntity;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity,\n        correlationId: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.setItem(\n            throttlingCacheKey,\n            JSON.stringify(throttlingCache),\n            correlationId\n        );\n    }\n\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.cookieStorage.getItem(key);\n            if (itemCookie) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\"\n                );\n                return itemCookie;\n            }\n        }\n\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (\n                this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage\n            ) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\n                        \"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\"\n                    );\n                    return item;\n                }\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\"\n            );\n            return null;\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\"\n        );\n        return value;\n    }\n\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(\n        cacheKey: string,\n        value: string,\n        generateKey?: boolean\n    ): void {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\"\n            );\n            this.cookieStorage.setItem(\n                key,\n                value,\n                undefined,\n                this.cacheConfig.secureCookies\n            );\n        }\n    }\n\n    /**\n     * Removes the cache item with the given key.\n     * @param key\n     */\n    removeItem(key: string): void {\n        this.browserStorage.removeItem(key);\n    }\n\n    /**\n     * Removes the temporary cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeTemporaryItem(key: string): void {\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\"\n            );\n            this.cookieStorage.removeItem(key);\n        }\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        return this.browserStorage.getKeys();\n    }\n\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    async clear(correlationId: string): Promise<void> {\n        // Removes all accounts and their credentials\n        await this.removeAllAccounts(correlationId);\n        this.removeAppMetadata(correlationId);\n\n        // Remove temp storage first to make sure any cookies are cleared\n        this.temporaryCacheStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.removeTemporaryItem(cacheKey);\n            }\n        });\n\n        // Removes all remaining MSAL cache items\n        this.browserStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.browserStorage.removeItem(cacheKey);\n            }\n        });\n\n        this.internalStorage.clear();\n    }\n\n    /**\n     * Clears all access tokes that have claims prior to saving the current one\n     * @param performanceClient {IPerformanceClient}\n     * @param correlationId {string} correlation id\n     * @returns\n     */\n    async clearTokensAndKeysWithClaims(\n        performanceClient: IPerformanceClient,\n        correlationId: string\n    ): Promise<void> {\n        performanceClient.addQueueMeasurement(\n            PerformanceEvents.ClearTokensAndKeysWithClaims,\n            correlationId\n        );\n\n        const tokenKeys = this.getTokenKeys();\n\n        let removedAccessTokens: number = 0;\n        tokenKeys.accessToken.forEach((key: string) => {\n            // if the access token has claims in its key, remove the token key and the token\n            const credential = this.getAccessTokenCredential(\n                key,\n                correlationId\n            );\n            if (\n                credential?.requestedClaimsHash &&\n                key.includes(credential.requestedClaimsHash.toLowerCase())\n            ) {\n                this.removeAccessToken(key, correlationId);\n                removedAccessTokens++;\n            }\n        });\n\n        // warn if any access tokens are removed\n        if (removedAccessTokens > 0) {\n            this.logger.warning(\n                `${removedAccessTokens} access tokens with claims in the cache keys have been removed from the cache.`\n            );\n        }\n    }\n\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key: string): string {\n        const generatedKey = this.validateAndParseJson(key);\n        if (!generatedKey) {\n            if (\n                StringUtils.startsWith(key, Constants.CACHE_PREFIX) ||\n                StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)\n            ) {\n                return key;\n            }\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n        }\n\n        return JSON.stringify(key);\n    }\n\n    /**\n     * Create authorityKey to cache authority\n     * @param state\n     */\n    generateAuthorityKey(stateString: string): string {\n        const {\n            libraryState: { id: stateId },\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(\n            `${TemporaryCacheKeys.AUTHORITY}.${stateId}`\n        );\n    }\n\n    /**\n     * Create Nonce key to cache nonce\n     * @param state\n     */\n    generateNonceKey(stateString: string): string {\n        const {\n            libraryState: { id: stateId },\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(\n            `${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`\n        );\n    }\n\n    /**\n     * Creates full cache key for the request state\n     * @param stateString State string for the request\n     */\n    generateStateKey(stateString: string): string {\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n        const {\n            libraryState: { id: stateId },\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n        return this.generateCacheKey(\n            `${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`\n        );\n    }\n\n    /**\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\n     */\n    getCachedAuthority(cachedState: string): string | null {\n        const stateCacheKey = this.generateStateKey(cachedState);\n        const state = this.getTemporaryCache(stateCacheKey);\n        if (!state) {\n            return null;\n        }\n\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        return this.getTemporaryCache(authorityCacheKey);\n    }\n\n    /**\n     * Updates account, authority, and state in cache\n     * @param serverAuthenticationRequest\n     * @param account\n     */\n    updateCacheEntries(\n        state: string,\n        nonce: string,\n        authorityInstance: string,\n        loginHint: string,\n        account: AccountInfo | null\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n        // Cache the request state\n        const stateCacheKey = this.generateStateKey(state);\n        this.setTemporaryCache(stateCacheKey, state, false);\n\n        // Cache the nonce\n        const nonceCacheKey = this.generateNonceKey(state);\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\n\n        // Cache authorityKey\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n        if (account) {\n            const ccsCredential: CcsCredential = {\n                credential: account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            };\n            this.setTemporaryCache(\n                TemporaryCacheKeys.CCS_CREDENTIAL,\n                JSON.stringify(ccsCredential),\n                true\n            );\n        } else if (loginHint) {\n            const ccsCredential: CcsCredential = {\n                credential: loginHint,\n                type: CcsCredentialType.UPN,\n            };\n            this.setTemporaryCache(\n                TemporaryCacheKeys.CCS_CREDENTIAL,\n                JSON.stringify(ccsCredential),\n                true\n            );\n        }\n    }\n\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(state: string): void {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n        // check state and remove associated cache items\n        if (state) {\n            this.temporaryCacheStorage.getKeys().forEach((key) => {\n                if (key.indexOf(state) !== -1) {\n                    this.removeTemporaryItem(key);\n                }\n            });\n\n            // delete generic interactive request parameters\n            this.removeTemporaryItem(this.generateStateKey(state));\n            this.removeTemporaryItem(this.generateNonceKey(state));\n            this.removeTemporaryItem(this.generateAuthorityKey(state));\n        }\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.URL_HASH)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)\n        );\n        this.setInteractionInProgress(false);\n    }\n\n    /**\n     * Removes temporary cache for the provided state\n     * @param stateString\n     */\n    cleanRequestByState(stateString: string): void {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n        // Interaction is completed - remove interaction status.\n        if (stateString) {\n            const stateKey = this.generateStateKey(stateString);\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n            this.logger.infoPii(\n                `BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`\n            );\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n        }\n    }\n\n    /**\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\n     * @param interactionType\n     */\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\n        this.logger.trace(\n            \"BrowserCacheManager.cleanRequestByInteractionType called\"\n        );\n        // Loop through all keys to find state key\n        this.temporaryCacheStorage.getKeys().forEach((key) => {\n            // If this key is not the state key, move on\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n                return;\n            }\n\n            // Retrieve state value, return if not a valid value\n            const stateValue = this.temporaryCacheStorage.getItem(key);\n            if (!stateValue) {\n                return;\n            }\n            // Extract state and ensure it matches given InteractionType, then clean request cache\n            const parsedState = extractBrowserRequestState(\n                this.cryptoImpl,\n                stateValue\n            );\n            if (\n                parsedState &&\n                parsedState.interactionType === interactionType\n            ) {\n                this.logger.infoPii(\n                    `BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`\n                );\n                this.resetRequestCache(stateValue);\n            }\n        });\n        this.setInteractionInProgress(false);\n    }\n\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest): void {\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n\n        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            encodedValue,\n            true\n        );\n    }\n\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(state: string): CommonAuthorizationCodeRequest {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            true\n        );\n        if (!encodedTokenRequest) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.noTokenRequestCacheError\n            );\n        }\n\n        let parsedRequest: CommonAuthorizationCodeRequest;\n        try {\n            parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n        } catch (e) {\n            this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n            this.logger.error(\n                `Parsing cached token request threw with error: ${e}`\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToParseTokenRequestCacheError\n            );\n        }\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\n        );\n\n        // Get cached authority and use if no authority is cached with request.\n        if (!parsedRequest.authority) {\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n            if (!cachedAuthority) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.noCachedAuthorityError\n                );\n            }\n            parsedRequest.authority = cachedAuthority;\n        }\n\n        return parsedRequest;\n    }\n\n    /**\n     * Gets cached native request for redirect flows\n     */\n    getCachedNativeRequest(): NativeTokenRequest | null {\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n        const cachedRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.NATIVE_REQUEST,\n            true\n        );\n        if (!cachedRequest) {\n            this.logger.trace(\n                \"BrowserCacheManager.getCachedNativeRequest: No cached native request found\"\n            );\n            return null;\n        }\n\n        const parsedRequest = this.validateAndParseJson(\n            cachedRequest\n        ) as NativeTokenRequest;\n        if (!parsedRequest) {\n            this.logger.error(\n                \"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\"\n            );\n            return null;\n        }\n\n        return parsedRequest;\n    }\n\n    isInteractionInProgress(matchClientId?: boolean): boolean {\n        const clientId = this.getInteractionInProgress();\n\n        if (matchClientId) {\n            return clientId === this.clientId;\n        } else {\n            return !!clientId;\n        }\n    }\n\n    getInteractionInProgress(): string | null {\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        return this.getTemporaryCache(key, false);\n    }\n\n    setInteractionInProgress(inProgress: boolean): void {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.interactionInProgress\n                );\n            } else {\n                // No interaction is in progress\n                this.setTemporaryCache(key, this.clientId, false);\n            }\n        } else if (\n            !inProgress &&\n            this.getInteractionInProgress() === this.clientId\n        ) {\n            this.removeTemporaryItem(key);\n        }\n    }\n\n    /**\n     * Returns username retrieved from ADAL or MSAL v1 idToken\n     * @deprecated\n     */\n    getLegacyLoginHint(): string | null {\n        // Only check for adal/msal token if no SSO params are being used\n        const adalIdTokenString = this.getTemporaryCache(\n            PersistentCacheKeys.ADAL_ID_TOKEN\n        );\n        if (adalIdTokenString) {\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\n        }\n\n        // Check for cached MSAL v1 id token\n        const msalIdTokenString = this.getTemporaryCache(\n            PersistentCacheKeys.ID_TOKEN,\n            true\n        );\n        if (msalIdTokenString) {\n            this.browserStorage.removeItem(\n                this.generateCacheKey(PersistentCacheKeys.ID_TOKEN)\n            );\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n        }\n\n        const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n        if (cachedIdTokenString) {\n            const idTokenClaims = AuthToken.extractTokenClaims(\n                cachedIdTokenString,\n                base64Decode\n            );\n            if (idTokenClaims.preferred_username) {\n                this.logger.verbose(\n                    \"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\"\n                );\n                return idTokenClaims.preferred_username;\n            } else if (idTokenClaims.upn) {\n                this.logger.verbose(\n                    \"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\"\n                );\n                return idTokenClaims.upn;\n            } else {\n                this.logger.verbose(\n                    \"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\"\n                );\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(\n        currentCacheKey: string,\n        credential: ValidCredentialType,\n        correlationId: string\n    ): string {\n        const updatedCacheKey = CacheHelpers.generateCredentialKey(credential);\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.browserStorage.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem, correlationId);\n                this.logger.verbose(\n                    `Updated an outdated ${credential.credentialType} cache key`\n                );\n                return updatedCacheKey;\n            } else {\n                this.logger.error(\n                    `Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`\n                );\n            }\n        }\n\n        return currentCacheKey;\n    }\n\n    /**\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n     * @param result\n     * @param request\n     */\n    async hydrateCache(\n        result: AuthenticationResult,\n        request:\n            | SilentRequest\n            | SsoSilentRequest\n            | RedirectRequest\n            | PopupRequest\n    ): Promise<void> {\n        const idTokenEntity = CacheHelpers.createIdTokenEntity(\n            result.account?.homeAccountId,\n            result.account?.environment,\n            result.idToken,\n            this.clientId,\n            result.tenantId\n        );\n\n        let claimsHash;\n        if (request.claims) {\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\n        }\n\n        /**\n         * meta data for cache stores time in seconds from epoch\n         * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\n         * We need to map these for the cache when building tokens from AuthenticationResult\n         *\n         * The next MSAL VFuture should map these both to same value if possible\n         */\n\n        const accessTokenEntity = CacheHelpers.createAccessTokenEntity(\n            result.account?.homeAccountId,\n            result.account.environment,\n            result.accessToken,\n            this.clientId,\n            result.tenantId,\n            result.scopes.join(\" \"),\n            result.expiresOn ? result.expiresOn.getTime() / 1000 : 0,\n            result.extExpiresOn ? result.extExpiresOn.getTime() / 1000 : 0,\n            base64Decode,\n            undefined, // refreshOn\n            result.tokenType as AuthenticationScheme,\n            undefined, // userAssertionHash\n            request.sshKid,\n            request.claims,\n            claimsHash\n        );\n\n        const cacheRecord = {\n            idToken: idTokenEntity,\n            accessToken: accessTokenEntity,\n        };\n        return this.saveCacheRecord(cacheRecord, result.correlationId);\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord {CacheRecord}\n     * @param storeInCache {?StoreInCache}\n     * @param correlationId {?string} correlation id\n     */\n    async saveCacheRecord(\n        cacheRecord: CacheRecord,\n        correlationId: string,\n        storeInCache?: StoreInCache\n    ): Promise<void> {\n        try {\n            await super.saveCacheRecord(\n                cacheRecord,\n                correlationId,\n                storeInCache\n            );\n        } catch (e) {\n            if (\n                e instanceof CacheError &&\n                this.performanceClient &&\n                correlationId\n            ) {\n                try {\n                    const tokenKeys = this.getTokenKeys();\n\n                    this.performanceClient.addFields(\n                        {\n                            cacheRtCount: tokenKeys.refreshToken.length,\n                            cacheIdCount: tokenKeys.idToken.length,\n                            cacheAtCount: tokenKeys.accessToken.length,\n                        },\n                        correlationId\n                    );\n                } catch (e) {}\n            }\n\n            throw e;\n        }\n    }\n}\n\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (\n    clientId: string,\n    logger: Logger\n): BrowserCacheManager => {\n    const cacheOptions: Required<CacheOptions> = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false,\n        cacheMigrationEnabled: false,\n        claimsBasedCachingEnabled: false,\n    };\n    return new BrowserCacheManager(\n        clientId,\n        cacheOptions,\n        DEFAULT_CRYPTO_IMPLEMENTATION,\n        logger\n    );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}